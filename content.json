{"pages":[{"title":"友链","text":"成本的 TG 频道，欢迎关注。 成本的日常这里是成本 xMuu 的日常频道，大概就是些乱七八糟（沙雕）的信息，什么都会有噢。 成本的直播通知摸鱼直播！直播摸鱼！随时咕咕咕。 广告位招租 想要成本帮忙宣传推荐频道也可以找我写到这里。收费 免费！","link":"/channels/index.html"},{"title":"友链","text":"成本的朋友们，都是大佬。 Beet’s BlogJust talk something! Butanediol’s Blog丁丁の店 Cn47mP’s Blog477 的博客 simonsmh - 后花园快来与我一起发现更加广阔的互联网世界吧 StarryVoid - Blog星光璀璨之空 Sukka’s Blog童话只美在真实却从不续写 yiheng’s Blogyiheng 的小窝 Zohar’s BlogThe Most Important Thing in My Life is Freedom 关于申请友链 无任何要求，只要是正常的站点可以来申请。可以通过 TG 或者发电的方式联系我。发送 站点名称 + 站点地址 + 一小段描述 给我即可。","link":"/links/index.html"}],"posts":[{"title":"打造一个有不同 Item 布局的 RecyclerView","text":"RecyclerView 作为 ListView 的升级版，其强大的性能和极高的灵活性使得可以在项目中实现更多的列表效果，比如瀑布流、自定义 Header 和 Footer 、不同内容的 Item 布局等，今天就利用 RecyclerView 来实现一个根据内容变化 Item 布局的列表布局，并添加一个横向滑动的列表作为 Header 。用到的主要是 RecyclerView.Adapter 中关于 View Type 的一些设定。 前期准备首先我们先新建一个类 ListItem 作为存放列表内容的对象。 ListItem.class 12345678910111213public class ListItem { int type; // Item 的类型 String title; // Item 的标题 String brief; // Item 的简介 String image; // Item 的图片 public ListItem(int type, String title, String brief, String image) { this.type = type; this.title = title; this.brief = brief; this.image = image; }} 列表样式设计这里我设计了 5 个不同的样式：列表的头部、仅有文字的列表项目、带有小图片的列表项目、带有大图片的列表项目和列表的尾部。列表的头部的是常见的左右滚动形式，其他几个部分则是简单的 Card ，最后列表的尾部为一行文字。 为了不贴出太多代码，影响阅读体验，这里就放出头部的和仅有文字的列表项目的 XML 文件，其他的文件会在项目的 GitHub Repo 中放出。 item_list_header.xml 这里使用一个 HorizontalScrollView 包裹一个 LinearLayout 实现横向滚动效果，实际使用时可以用一个横向的 RecyclerView 替代。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;HorizontalScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:scrollbars=&quot;none&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:scrollbars=&quot;none&quot;&gt; &lt;androidx.cardview.widget.CardView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:layout_marginVertical=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/header_image_1&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;200dp&quot; android:contentDescription=&quot;@string/image_description&quot;/&gt; &lt;/androidx.cardview.widget.CardView&gt; ... ... &lt;/LinearLayout&gt;&lt;/HorizontalScrollView&gt; item_text_only.xml 简单的一个 CardView 。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot;&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/item_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:textSize=&quot;20sp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/item_brief&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginBottom=&quot;16dp&quot; android:textSize=&quot;16sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/item_title&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/androidx.cardview.widget.CardView&gt; 创建 Adapter ListAdapter.java 这里大体跟一般使用 RecyclerView.Adapter 一样，但是重写了 getItemViewType() 方法，根据 position 返回不同的 Type ，getItemCount() 的返回值也从一般的列表 Size 变成了 Size + 2 ，因为多了头部和尾部两个项目。其他的一些改动请看代码，部分重复或无关代码已省略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class ListAdapter extends RecyclerView.Adapter&lt;ListAdapter.ItemViewHolder&gt; { ... ... public ListAdapter(Context context, List&lt;ListItem&gt; mData) { this.mContext = context; this.mData = mData; } @Override public int getItemViewType(int position) { // 根据位置和内容判断布局类型 if (position == 0) { return TYPE_HEADER; } else if (position == getItemCount() - 1) { return TYPE_FOOTER; } else { return mData.get(position - 1).type; } } @NonNull @Override public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { // 应用不同布局 switch (viewType) { case TYPE_HEADER: return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_list_header, parent, false), viewType); case TYPE_NO_IMAGE: return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_text_only, parent, false), viewType); case TYPE_SMALL_IMAGE: return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_text_with_small_image, parent, false), viewType); case TYPE_BIG_IMAGE: return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_text_with_big_image, parent, false), viewType); default: return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_list_footer, parent, false), viewType); } } @Override public void onBindViewHolder(@NonNull ItemViewHolder holder, int position) { // 根据类型对内容进行设置 if (holder.type == TYPE_HEADER) { String imgURL1 = &quot;file:///android_asset/1.jpg&quot;; Glide.with(mContext) .load(imgURL1) .centerCrop() .into(holder.headerImage1); ... ... } else if (holder.type != TYPE_FOOTER) { holder.textTitle.setText(mData.get(position - 1).title); holder.textBrief.setText(mData.get(position - 1).brief); if (holder.type == 2 || holder.type == 3) { // 简单的图片加载 String imgURL = &quot;file:///android_asset/&quot; + mData.get(position - 1).image + &quot;.jpg&quot;; Glide.with(mContext) .load(imgURL) .centerCrop() .into(holder.imageView); } } } @Override public int getItemCount() { // 计算头部和尾部项目 return mData.size() + 2; } static class ItemViewHolder extends RecyclerView.ViewHolder { int type; ImageView headerImage1, headerImage2, headerImage3; TextView textTitle, textBrief; ImageView imageView; public ItemViewHolder(@NonNull View itemView, int viewType) { super(itemView); this.type = viewType; textTitle = itemView.findViewById(R.id.item_title); textBrief = itemView.findViewById(R.id.item_brief); // 根据不同布局设置界面元素 if (viewType == 0) { headerImage1 = itemView.findViewById(R.id.header_image_1); headerImage2 = itemView.findViewById(R.id.header_image_2); headerImage3 = itemView.findViewById(R.id.header_image_3); } if (viewType == 2 || viewType == 3) { imageView = itemView.findViewById(R.id.item_image); } } }} 实装 RecyclerView这部分就是给 RecyclerView 设置刚刚完成的 Adapter ，然后填上对应的内容，至此，整个列表就完成了。 123456789101112131415161718192021public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); // 设置列表内容 List&lt;ListItem&gt; listItems = new ArrayList&lt;&gt;(); listItems.add(new ListItem(1, &quot;标题1&quot;, &quot;简介1&quot;, &quot;1&quot;)); listItems.add(new ListItem(2, &quot;标题2&quot;, &quot;简介2&quot;, &quot;2&quot;)); listItems.add(new ListItem(3, &quot;标题3&quot;, &quot;简介3&quot;, &quot;3&quot;)); // 设置 RecyclerView RecyclerView recyclerView = findViewById(R.id.recycler_view); recyclerView.setLayoutManager(new LinearLayoutManager(this)); recyclerView.setAdapter(new ListAdapter(this, listItems)); }} 效果展示就是上面那个图片啦，我是做出来才截图的。 源码以及 Demo整个过程的源码已经上传到 GitHub ，项目地址：点这里 ，如有错误或瑕疵，欢迎提出。 如果想试试整个 App 的效果可以到这里下载体验。","link":"/2020/07/25/android-recycler-view-with-many-styles/"},{"title":"Android 开发中使用 Room 快速构建 SQLite 数据库","text":"Room 是 Google 提供的一个 ORM (Object Relational Mapping) 库，可以在 Android 开发中快速流畅地进行数据库访问。Room 提供了一个访问 SQLite 的抽象层，通过解析注解内容自动生成对应代码，大大提高了开发的效率。 Room 包含 3 个主要组件： 数据库：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。 DAO：包含用于访问数据库的方法。 Entity：表示数据库中的表。 具体的各个组件的说明请查阅官方文档（地址）。下面将讲解如何使用 Room 快速构建一个数据库并配合 RecyclerView 输出数据库内容，实现一个简单的购物清单。 文中代码重复度较高的地方会进行省略，如果需要完整代码请到文末 GitHub 仓库获取 新建工程在 Android Studio 中创建一个新工程，这里我选用 Basic Activity 模板，你可以根据自己的需求选不同的模板来创建工程。 引入依赖在应用或模块的 build.gradle 文件中添加： 12345678910111213141516171819202122232425dependencies { // 设置 Room 版本，此处可能不是最新版，请自行选择是否更新到最新版 def room_version = &quot;2.2.5&quot; implementation &quot;androidx.room:room-runtime:$room_version&quot; annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot; // For Kotlin use kapt instead of annotationProcessor // 对于 Kotlin 用户请使用 kapt 代替 annotationProcessor // optional - Kotlin Extensions and Coroutines support for Room // 可选 - Kotlin 扩展和 Coroutines 支持 implementation &quot;androidx.room:room-ktx:$room_version&quot; // optional - RxJava support for Room // 可选 - RxJava 支持 implementation &quot;androidx.room:room-rxjava2:$room_version&quot; // optional - Guava support for Room, including Optional and ListenableFuture // 可选 - Guava 支持 implementation &quot;androidx.room:room-guava:$room_version&quot; // Test helpers // 测试工具 testImplementation &quot;androidx.room:room-testing:$room_version&quot;} 添加完成后记得点击右上角的 Sync Now 同步一下依赖。 创建数据库创建 Entity新建一个名为 ListItem.java 的文件： 123456789101112131415161718192021222324252627282930313233343536@Entity(tableName = &quot;items&quot;) // 自定义表名public class ListItem { @PrimaryKey(autoGenerate = true) // 注明此元素为主键并自动生成 public int ID; @ColumnInfo(name = &quot;ItemName&quot;) // 自定义列名 public String Name; @ColumnInfo(name = &quot;ItemNumber&quot;, defaultValue = &quot;1&quot;) // 设置默认值 public String Number; @ColumnInfo(name = &quot;ItemStatus&quot;, defaultValue = &quot;false&quot;) public boolean Status; // 需要手动创建一个空的构造函数，否则编译时会报错 public ListItem() { } // 这个是为了创建对象时方便的构造函数 public ListItem(String name, String number) { Name = name; Number = number; } // 必须为所有的列创建 getter 和 setter 以便进行访问 public int getID() { return ID; } public void setID(int ID) { this.ID = ID; } ...} 实现 DAODAO(Data Access Object, 中文为数据访问对象) 是一个面向对象的数据库接口，所以我们新建一个 interface 名为 ListItemDAO.java ，实现数据操作的一些定义： 123456789101112131415@Daopublic interface ListItemDAO { @Insert // 插入操作 void insert(ListItem... items); // 对象类后加三个点表示多个对象，添加时使用逗号分隔 @Delete // 删除操作 void delete(ListItem... items); @Update // 更新操作 void update(ListItem... items); @Query(&quot;SELECT * FROM items&quot;) // 查询全部数据，可根据需求添加查询条件 LiveData&lt;List&lt;ListItem&gt;&gt; getAllItems();} 创建 AppDatabase这一步我们来创建整个 App 的数据库。新建一个文件名为 AppDatabase.java ，设置其为 abstract 并继承于 RoomDatabase ： 如果您的应用在单个进程中运行，则在实例化 AppDatabase 对象时应遵循单例设计模式。每个 RoomDatabase 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。 12345678910111213141516171819@Database(entities = {ListItem.class}, version = 1, exportSchema = false)// 注解中设置好需要使用的实体 entities ，多个请用逗号隔开// 版本号 version 必须要写，以便后期升级迁移数据库// exportSchema 如果有需求请打开并实现相应内容，如没实现且没关闭，编译将会报错public abstract class AppDatabase extends RoomDatabase { // 实现单例模式 private static AppDatabase INSTANCE; public static synchronized AppDatabase getAppDatabase(Context context) { if (INSTANCE == null) { INSTANCE = Room.databaseBuilder(context.getApplicationContext(), AppDatabase.class, &quot;AppDatabase&quot;).build(); } return INSTANCE; } // 添加对应的 Dao public abstract ListItemDAO getListItemDAO();} 至此，整个数据库已经创建完毕，可以通过 DAO 对数据库进行操作： 12345// 插入数据ListItem example = new ListItem(&quot;牙刷&quot;, 2);AppDatabase appDatabase = AppDatabase.getAppDatabase(context);ListItemDAO listItemDAO = appDatabase.getListItemDAO();listItemDAO.insert(example); 但是这样操作存在一定问题： 直接调用的话，对数据库的操作在主线程上执行，可能会因数据过大而造成 UI 卡顿 每次都要获取 AppDatabase 实例和 ListItemDAO ，过程繁琐，代码重复 所以我们来新建一个仓库，用来简化代码，并实现多线程来进行数据库操作，避免卡顿。 创建操作仓库新建名为 ListItemRepository.java 的文件： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListItemRepository { private ListItemDAO listItemDAO; public ListItemRepository(Context context) { // 获取 AppDatabase 并获取对应 DAO AppDatabase appDatabase = AppDatabase.getAppDatabase(context); listItemDAO = appDatabase.getListItemDAO(); } // LiveData 类型会自动在进行多线程操作，无需手动新建多线程异步操作任务 public LiveData&lt;List&lt;ListItem&gt;&gt; getAllItems() { return listItemDAO.getAllItems(); } // 调用多线程异步操作任务 public void addListItem(ListItem... items) { new insertAsyncTask(listItemDAO).execute(items); } ... // 创建多线程异步操作任务 static class insertAsyncTask extends AsyncTask&lt;ListItem, Void, Void&gt; { private ListItemDAO listItemDAO; insertAsyncTask(ListItemDAO listItemDAO) { this.listItemDAO = listItemDAO; } @Override protected Void doInBackground(ListItem... items) { listItemDAO.insert(items); return null; } } ...} 现在我们就可以用这样的方式来操作数据库了： 12345678// 一次创建，多次使用，多线程操作，不会导致 UI 卡顿ListItem example = new ListItem(&quot;牙刷&quot;, 2);ListItemRepository repository = new ListItemRepository(context);repository.addListItem(example);repository.addListItem(example);// 也可以直接新建一个仓库并使用new ListItemRepository(context).updateListItem(temp); 这样代码写起来就非常方便了，不用再啰啰嗦嗦去获取 DAO 。 创建 RecyclerView现在我们来正式使用数据库。在布局文件中添加 RecyclerView 并新建对应文件。这里以 fragment_first.xml 为例： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.FirstFragment&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 创建布局文件以 item_list.xml 为例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/list_item&quot;&gt; &lt;CheckBox android:id=&quot;@+id/checkbox&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;false&quot; android:layout_margin=&quot;10dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/item_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;24sp&quot; android:text=&quot;@string/app_name&quot; android:layout_marginHorizontal=&quot;10dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@id/checkbox&quot;/&gt; &lt;TextView android:id=&quot;@+id/item_number&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;22sp&quot; android:text=&quot;@string/app_name&quot; android:layout_marginHorizontal=&quot;20dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot;/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 创建 Adapter以 ListAdapter.java 为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ListAdapter extends RecyclerView.Adapter&lt;ListAdapter.ItemViewHolder&gt; { private List&lt;ListItem&gt; mData; // 创建构造函数，传入数据 public ListAdapter(List&lt;ListItem&gt; mData) { this.mData = mData; } @NonNull @Override public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { return new ItemViewHolder(LayoutInflater.from(parent.getContext()).inflate( R.layout.item_list, parent, false)); } // 重写元素绑定逻辑 @Override public void onBindViewHolder(@NonNull ItemViewHolder holder, final int position) { // 设置元素内容 holder.itemStatus.setChecked(mData.get(position).Status); holder.itemName.setText(mData.get(position).Name); String number = &quot;数量：&quot; + mData.get(position).Number; holder.itemNumber.setText(number); // 添加单击修改状态事件 holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { ListItem temp = mData.get(position); temp.Status = !temp.Status; new ListItemRepository(v.getContext()).updateListItem(temp); } }); // 添加长按删除事件 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { final ListItem temp = mData.get(position); new ListItemRepository(v.getContext()).deleteListItem(temp); Snackbar.make(v, &quot;物品已删除&quot;, Snackbar.LENGTH_LONG) .setAction(&quot;撤销&quot;, new View.OnClickListener() { @Override public void onClick(View v) { new ListItemRepository(v.getContext()).addListItem(temp); } }).show(); return true; } }); } @Override public int getItemCount() { return mData.size(); } // 绑定列表项目的各个元素 static class ItemViewHolder extends RecyclerView.ViewHolder { CheckBox itemStatus; TextView itemName, itemNumber; ItemViewHolder(@NonNull View itemView) { super(itemView); itemStatus = itemView.findViewById(R.id.checkbox); itemName = itemView.findViewById(R.id.item_name); itemNumber = itemView.findViewById(R.id.item_number); } }} 设置 RecyclerView在对应的位置添加上 RecyclerView 的初始化代码，这里以 FirstFragment.java 为例： 1234567891011121314151617181920212223242526public class FirstFragment extends Fragment { private RecyclerView recyclerView; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_first, container, false); } public void onViewCreated(@NonNull View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); ListItemRepository repository = new ListItemRepository(view.getContext()); // 绑定 RecyclerView recyclerView = view.findViewById(R.id.list); // 设置 RecyclerView 布局管理器 recyclerView.setLayoutManager(new LinearLayoutManager(view.getContext())); // 动态监听 ListItem 的变化并设置 RecyclerView Adapter repository.getAllItems().observe(getViewLifecycleOwner(), new Observer&lt;List&lt;ListItem&gt;&gt;() { @Override public void onChanged(List&lt;ListItem&gt; listItems) { recyclerView.setAdapter(new ListAdapter(listItems)); } }); }} 添加按钮功能给 MainActivity 的浮动按钮添加一个弹出对话框的效果，用来添加新物品到数据库： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends AppCompatActivity { private ListItemRepository repository; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); repository = new ListItemRepository(getApplicationContext()); FloatingActionButton fab = findViewById(R.id.fab); // 为浮动按钮设置点击监听 fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { createNewItemDialog(view).show(); } }); } // 创建对话框 private AlertDialog createNewItemDialog(final View view) { final View dialogView; LayoutInflater inflater = getLayoutInflater(); AlertDialog.Builder builder = new AlertDialog.Builder(Objects.requireNonNull(view.getContext())); dialogView = inflater.inflate(R.layout.dialog_layout, null); builder.setTitle(&quot;添加新物品&quot;).setView(dialogView); builder.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { TextInputEditText itemNameInput = dialogView.findViewById(R.id.item_name_input); TextInputEditText itemNumberInput = dialogView.findViewById(R.id.item_number_input); String name = Objects.requireNonNull(itemNameInput.getText()).toString(); String number = Objects.requireNonNull(itemNumberInput.getText()).toString(); if (!name.equals(&quot;&quot;)) { repository.addListItem(new ListItem(name, number)); Snackbar.make(view, &quot;物品已添加&quot;, Snackbar.LENGTH_SHORT).show(); } else { Snackbar.make(view, &quot;物品名称不能为空&quot;, Snackbar.LENGTH_SHORT).show(); } } }); builder.setNegativeButton(&quot;取消&quot;, null); return builder.create(); }} 效果展示布局不太好看，不要介意，看效果就好。 源码以及 Demo整个过程的源码已经上传到 GitHub ，项目地址：点这里 ，如有错误或瑕疵，欢迎提出。 如果想试试整个 App 的效果可以到这里下载体验。","link":"/2020/04/14/android-using-room-to-build-a-sqlite-database-quickly/"},{"title":"使用 GitHub Pages 和 Travis CI 搭建自动构建的 Hexo 博客","text":"简介Hexo 是个好东西，GitHub Pages 也是个好东西，那如何将这两个好东西放在一起用呢？那就是用 Travis CI 了。 本文的目的是使用 Travis CI 来自动生成并提交 Hexo 生成的静态页面到 GitHub Pages 仓库。 准备工作 一个良好的网络 一个 GitHub 账号 配置好 Git 参考 Hexo 文档装好 hexo-cli （文档地址） 启用 Travis CI使用 GitHub 账号登录 Travis CI ，授权 Travis CI 获取 GitHub 账户的资料。完成后，会跳转到 Travis CI 的页面，页面里面应该会提示你 Activate all repositories using GitHub Apps （对所有 GitHub 项目启用 Travis CI 自动构建），点击按钮后授权，以后新建的项目就都会自动启用 Travis CI 了。 创建 GitHub Repositories在 GitHub 上创建 GP 仓库（仓库名为 GitHub 用户名 + .github.io ）和博客源码仓库（以下为 blog-factory ），均设置为公开仓库即可。 Note: 如果你不被人看到源码，那源码仓库也可以为私密仓库，但是 Travis CI 的自动构建只对公开仓库免费，私密仓库据说只有前一百次免费。 创建完仓库后，将源码仓库克隆至本地。 准备博客源码 在本地创建一个空文件夹（这里为 blog-temp ），用来生成博客的源码。 Note: 之所以要另起一个文件夹是因为 Hexo 的 init 指令只能作用于空文件夹。 在终端中打开 blog-temp 并执行以下命令：hexo init .执行完毕后，将 blog-temp 的内容复制到源码仓库 blog-factory 的文件夹中。（ .git 文件夹不要复制。） 修改博客配置Hexo 博客的配置文件是项目根目录的 _config.yml ，根据需求修改配置文件。如果要安装主题、插件之类，也在这里配置好。 测试博客 执行 hexo server --debug确认是否能正常生成博客文件。 访问 http://localhost:4000确定博客能正常访问，没有 404 或者其他错误。 完成后 Ctrl + C 结束进程，执行 hexo clean 清理无用文件。 编写 Travis CI 配置文件在项目根目录创建文件 .travis.yml 。（注意，是以 . 开头的文件，在一些文件管理器中可能不会直接显示，需要打开相关设置。）接下来在这个文件里面写入以下内容： 1234567891011121314151617181920212223242526272829303132language: node_js # 设置语言类型node_js: stable # 选择版本sudo: false # 设置权限branches: # 设置触发 CI 运行的分支 only: - sourcecache: # 设置缓存，可以有效提高 CI 编译的速度 directories: - node_modules before_install: # 设置在安装之前的一些操作 - export TZ='Asia/Shanghai' # 设置时区，于本地时间同步，防止一些时间的错误install: # 安装需要的工具 - npm install -g hexo-cli # 安装 Hexo - npm install # 安装 Hexo 依赖 # 如果有需要安装的插件，或者是主题需要安装的依赖，也一并在在这里安装 # 切换目录后最终需要回到根目录，注意返回script: - hexo g # 生成静态 HTML 文件after_script: - cd ./public - git init - git config user.name &quot;${GH_NAME}&quot; - git config user.email &quot;${GH_EMAIL}&quot; - git add . - git commit -m &quot;Travis CI Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')&quot; - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REPO}&quot; master:master 这样，整个构建和推送的流程脚本就编写完成了，到时候 Travis CI 就会按照上面的顺序执行，将生成的 HTML 文件推送到指定仓库指定分支。 生成 GitHub Token打开 Github 的 Settings 页面，点击左边的 Developer settings ，然后选择 Personal access tokens ，点击 Generate new token ，生成一个 Token 。在新页面中填入 Note ，设置一个名字或者其他有助于你记忆这个 Token 用途的信息，然后勾选下方 repo 的勾，会连带勾上四个子选项。之后就拉到最下面直接保存，在新页面中会显示这个 token ，保存好，下一步要用到。 设置 Travis CI 环境变量在上面的配置文件中，出现了 ${GH_NAME} ， ${GH_EMAIL} ， ${GH_TOKEN} ， ${GH_REPO} 这几个字符串，其实这个是 Travis CI 的变量引用，在执行的时候会被自动替换成已经设置好的值，现在就要来设置这几个值。 打开 Travis CI ，登录后点击右上角设置，在设置界面可以看到 GitHub 里面所有的 Repositories ，如果没有，请检查你的授权，让 Travis CI 可以获取到你的 Repositories 。 点击 blog-factory 右边的设置按钮，可以看到设置的页面，里面有一项名为 Environment Variables 的设置类。 依次添加名为 GH_NAME ， GH_EMAIL ， GH_TOKEN ，GH_REPO ，填入对应的值。 NAME VALUE GH_NAME xMuu GH_EMAIL mail@mail.com GH_TOKEN 421ddfe66ed5a56ba19d6d1e1*************** GH_REPO github.com/xMuu/xmuu.github.io Note : GH_TOKEN 应该保存好，避免泄漏，在设置的时候不要打开 DISPLAY VALUE IN BUILD LOG 。 上传博客源码首先整理一下目录的内容，删除没有用的各种文件。顺便执行一次 Hexo 的清理程序：hexo clean之后，检查安装的主题，是否有 .git 文件夹，有的话需要删除。一切检查完毕后就在 blog-factory 目录下，执行以下命令，将博客源码上传至 GitHub 。 123git add .git commit -m &quot;upload blog source&quot;git push 查看结果上传过后，可以到 Travis CI 看看构建的过程，也可以直接等待 Travis CI 的邮件然后访问 GitHub Pages 查看结果。 附录1. 主题有 npm 依赖如果主题需要安装 npm 依赖，如果依赖多的话，建议在 Travis CI 构建的时候使用 npm install 安装，记得在上传源码的时候在 .gitignore 中排除主题目录下的 node_modules 文件夹；不多的话则可以直接将 node_modules 附带上去。","link":"/2020/02/22/build-a-hexo-blog-with-github-pages-and-travis-ci/"},{"title":"在 Ubuntu 18.04 中使用 Netplan 配置网络","text":"在 Ubuntu 升级到 18.04 之后（准确的是在 Ubuntu 17.10 以后），原先管理网络配置的 ifupdown 被替换成了 Netplan ，这使得之前的一些配置无法直接搬到新的系统中继续使用，所以来学习一下这个新工具，Netplan 。 什么是 NetplanNetplan 是 Canonical 推出的一款抽象网络配置生成器，可以通过一个或多个 yaml 格式的配置文件，生成所需的网络配置，并应用到系统中。用户只需要在配置文件中描述好每个网络接口的各种参数属性，即可生成适用于 NetworkManager （一般用于桌面环境）或 Systemd-networkd （一般用于服务器环境）的网络配置。我对它的理解就是，你对于计算机网络的规划，你希望计算机的网络是什么样的，你就怎么写配置文件，它就按照你的配置文件帮你生成网络配置文件，是非常简单明了的工具。 它的工作原理如下： Netplan 工作原理 为什么要 Netplan在 Netplan 没有出来之前，Ubuntu 的网络配置一直是 ifupdown 管理，配置文件冗长，可读性不高，甚至有一些是无法用配置文件进行描述的。 12345678910111213141516# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto ens3iface ens3 inet static address 192.168.1.2 netmask 255.255.255.0 gateway 192.168.1.1 dns-nameservers 8.8.8.8 8.8.4.4 而且，ifupdown 的配置文件并不能跨设备通用，每个设备的网卡信息都是固定的。在批量部署设备网络时，Netplan 拥有的 match 功能显然更胜一筹，用户可以通过名称、MAC 地址或者是内核驱动名称来匹配网络接口，从而实现用一份配置文件来配置多个设备的网络。 除此之外，Netplan 不会在引导期间进行过多的配置操作，再也不会因为开机等待 DHCP 而卡住等半天了，一些没有被配置文件涵盖的设备也不会被触发，所有的配置都是在开机的时候读取配置文件生成的，只加载必要的部分，大大提高了开机的效率。 说了这么多，让我们开始 Netplan 的配置吧。 Netplan 配置文件Netplan 的配置文件存放于三个不同的位置分别是 /run/netplan/ ，/etc/netplan/ 和 /lib/netplan/ ，我们修改的是 /etc/netplan/ 目录下的配置文件，其他两个目录会在配置生效的时候自动同步配置。你可以在配置文件目录下存放多个 yaml 文件，它们会被按照字母顺序加载，并且同名值会被后加载的覆盖。 基础配置文件下面是一个基础的配置文件，这份配置文件会 NetworkManager 接管所有的网络设备，并所有以太网设备启用默认 DHCP（如果找到 DHCP 服务器的话）。如果将 renderer 改为 Systemd-networkd 的话，则不会启用 DHCP ，需要在配置文件指定设备才会启用。 编写配置文件的时候，缩进时要使用空格，不可使用 Tab 来缩进，空格数量不做要求，但是每一层级前面的空格数量必须相同，否则会导致配置文件读取错误。 123network: version: 2 renderer: network-manager 显然，这样一份配置文件是不够的，我们需要更加详细的配置文件来适应各种需求。 为指定设备启用 DHCP为网卡 enp3s0 启用 IPv4 的 DHCP 并禁用 IPv6 的 DHCP 。 1234567network: version: 2 renderer: network-manager ethernets: enp3s0: dhcp4: true dhcp6: false 为指定设备配置静态 IP这里我们来为网卡 enp3s0 设置一个静态的内网 IP ： 12345678910111213network: version: 2 renderer: network-manager ethernets: enp3s0: addresses: - 192.168.1.101/24 gateway4: 192.168.1.1 nameservers: addresses: - 119.29.29.29 - 119.28.28.28 # [119.29.29.29, 119.28.28.28] 在书写这份文件的时候要注意： 原本的 IP 地址和子网掩码被合二为一成为这里的 addresses ，使用的是 CIDR 表示法，而且这里是复数形式，也就是说，可以在这里写多个地址，不区分 IPv4 和 IPv6 。 网关这里使用的是 IPv4 的网关，所以名称为 gateway4 ，如果要使用 IPv6 ，则应该另起一行再写一个 gateway6 ，并设置好 IPv6 的 IP 地址。 nameservers 中的地址 addresses 我使用了两种写法，一种是列表的写法，一种是括号的写法，两种写法是等价的。 配置无线网卡设备在给树莓派等设备配置网络的时候，经常会要连接 Wi-Fi ，如果有图形界面还比较简单，要是没有图形界面，可能有时候就没那么方便了。但是用 Netplan 的话，一切都很方便。下面就是一个简单的无线网络配置文件，你甚至不用声明是 WAP 认证方式： 1234567891011network: version: 2 renderer: network-manager wifis: wlp1s0: dhcp4: yes access-points: &quot;AccessPoint1&quot;: # SSID password: &quot;**********&quot; &quot;AccessPoint2&quot;: password: &quot;**********&quot; 如果你用的是 WAP with EAP 等比较复杂的认证方式，用 Netplan 也可以轻松解决： 1234567891011121314network: version: 2 renderer: network-manager wifis: wlp1s0: dhcp4: yes access-points: &quot;AccessPointWithEAP&quot;: auth: key-management: eap # 管理系统 method: ttls # 认证模式 anonymous-identity: &quot;@example.com&quot; identity: &quot;example@example.com&quot; password: &quot;*********&quot; 多路网卡配置假如你的电脑有两个网卡，同时接入了两个不同的 DHCP 网络，你可以设置优先级来让系统自动选择网络：（在这里 enfirst 比 ensecond 有着更高的优先级） 123456789101112network: version: 2 renderer: networkd ethernets: enfirst: dhcp4: yes dhcp4-overrides: route-metric: 100 # 优先级为 100 ensecond: dhcp4: yes dhcp4-overrides: route-metric: 200 # 优先级为 200 除了上述这些简单常见的配置，Netplan 还支持网桥、调制解码器（Modems）、隧道、VLAN 等等设备的配置，更多的配置请参阅官网的文档。 应用 Netplan 配置在编写完成配置文件后，我们可以在终端执行指令 generate 来生成配置文件： 1sudo netplan generate 然后使用 apply 来应用生成的配置文件，必要时它会重启对应的网络服务： 1sudo netplan apply 也可以使用 try 来测试生成的配置文件，如果失败了，则会自动回滚到上一次的配置文件，成功则可以按 Enter 应用配置文件： 1sudo netplan try 总结Netplan 作为新的网络配置生成器，配置文件简单，可用性高，操作方便，而且带有试错机会，可以说再也不用担心配不好 Linux 服务器的网络啦。建议大家都用一用，体验一下这种新鲜的配网方式。更多的用法就请看 Netplan 的官网啦：https://netplan.io","link":"/2021/02/03/config-network-in-ubuntu-18-04-with-netplan/"},{"title":"修复 Android Studio 自带的 BottomNavigationView 中 Fragment 位置错误","text":"最近在玩 Android Studio 里面的 BottomNavigationView ，在使用的时候发现了一点问题，自动创建的 Fragment 位置会偏下，研究了一下，找到了修复位置错误的办法。 TL; DR 删除 activity_main.xml 中的 android:paddingTop=&quot;?attr/actionBarSize&quot; 属性 为 activity_main.xml 中的 nav_host_fragment 添加 android:layout_marginBottom=&quot;?attr/actionBarSize&quot; 属性 发现问题新建完 BottomNavigationView 后通过虚拟机启动，可以看到以下画面，没有别的元素时，不会发现问题。（其实如果眼尖一点，可以发现文字不是居中的。） 但是如果我们在任意一个 Fragment 里面创建一点内容，这里以一个带颜色的 View 和原本自带的文字为例，View 我设置宽高均匹配父元素，把文本放到了底部的位置，代码如下。 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.ui.home.HomeFragment&quot;&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; /&gt; &lt;TextView android:id=&quot;@+id/text_home&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;8dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:textAlignment=&quot;center&quot; android:textSize=&quot;20sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot;/&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 在编辑器里面预览的效果是这样： 现在，让我们再次启动程序，就会发现，View 的上方少了一块，本该在底部的文字也不见了。 排查问题 可以看到，Fragment 的上方是没有跟父级元素贴合的，这个就导致了 Fragment 没有跟上方贴合。 解决问题一番 Google 后并没找到什么别人的解决方案，就自己在项目里到处看，最后发现，在 activity_main.xml 中的外层框架，有个属性 android:paddingTop=&quot;?attr/actionBarSize&quot; ，意思是在上方空出空间给 Action Bar ，而这个代码本身的 Action Bar 并不需要预留空间，所以去掉这个就好了。 现在的效果就是这样： 诶？文字呢？怎么文字还是看不到？ 再回去编辑器里看，发现底部的导航栏其实是覆盖在 Fragment 上的，也就是说文字被这个挡住了，那再来一个 padding 吧，这次加给 Fragment 就好了， android:layout_marginBottom=&quot;?attr/actionBarSize&quot; ，导航栏的高度是跟顶部 Action Bar 一样的。 这下子就没问题了： 以上就是修正 BottomNavigationView 中 Fragment 位置错误的完整过程啦，其实就是水博客。（","link":"/2020/03/14/fix-fragment-position-in-bottom-navigation-view/"},{"title":"Say Hello World Again","text":"2020 就这样过去了，这一年真的是太魔幻了，发生了各种各样的事情，胖了好多斤，但是好像没做多少事情，趁着年末，给自己换了个域名，给博客换了套主题，顺便来给自己整理一下下一年要做的事情。（立几个大的 Flag 2021 成本想完成的事情： 按照自己的想法完善这个博客主题，搞一个夜间模式，加一些其他的模块。成本版的主题在这：xMuu/hexo-theme-icarus 坚持每日一题，多刷 LeetCode 。目标是刷完《剑指 Offer》，然后在 LeetCode CN 上刷完 300 道题。 完成 MyOneDay 这个自己想的小项目。Java 版已经可以在酷安下载：商店页面今年要把功能完成，并加入数据导入导出功能，尽可能上云，提供云备份功能。 挑战任务：Codeforces 上分，目标 1400 分。现在分数有点低，之前没有好好对待这个，现在要认真对待了。 欢迎来督促成本，督促有(wu)奖23332021 加油，有缘的话 2077 再见。（还没玩过 2077 呜呜呜","link":"/2020/12/31/hello-world/"},{"title":"安装 Arch Linux 后的一点微小的工作","text":"记录一下安装 Arch 之后一些需要的操作。 开机前禁用 N 卡开源驱动并用 bbswitch 禁用 N 卡 Fxxk NVIDIA～（ 这一步是解决一些机子开机卡住的问题，并关闭 N 卡提高使用体验（解决发热 &amp; 提高续航）。 首先禁用 nouveau 驱动 sudo nano /etc/modprobe.d/blacklist-nouveau.conf 输入 blacklist nouveau 并保存 安装 bbswtich sudo pacman -S bbswitch 接着新建配置文件 /etc/modprobe.d/bbswitch.conf sudo nano /etc/modprobe.d/bbswitch.conf 写入 options bbswitch load_state=0 并保存 再新建一个配置文件 /etc/modules-load.d/bbswitch.conf sudo nano /etc/modules-load.d/bbswitch.conf 写入 bbswitch 并保存 这样开机就会加载 bbswitch 模块并关闭 N 卡了。 安装 zsh sudo pacman -S zsh oh-my-zsh 用脚本装可以直接获取更新不用等打包。 添加用户的时候加上参数 -s /bin/zsh 即可将默认 shell 设置为 zsh 。 配置国内镜像源和第三方仓库 编辑 /etc/pacman.conf sudo nano /etc/pacman.conf Misc options 中取消 Color ， TotalDownload ， VerbosePkgLists 的注释 取消下方 multilib 的两行注释，注意不是 testing 那两行 在文件的最下方添加 12345[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch [arch4edu]Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch 保存后执行 sudo pacman -Syy 更新软件源数据库即可 archlinuxcn : Arch Linux CN 源，作为官方社区源的补充，上面有很多官方源没有的软件包，还有些国内特色的包。arch4edu : 面向高校用户推出的非官方软件仓库，主要包含高校用户常用的科研、教学及开发软件。 安装桌面环境以及一些其他东西 我是坚定的 KDE 党！（ sudo pacman -S plasma konsole dolphin # 如果有选项记得选 vlcsudo pacman -Rcun discover # 删除自带的商店，不删也行，但是这东西真的没啥用sudo pacman -S pulseaudio-bluetooth alsa-plugins alsa-utilssudo systemctl enable sddmsudo systemctl enable NetworkManager 配置中文字体中文字体我选择了 Apple 的苹方字体（中文）搭配 SF-Pro （西文）这套解决方案。具体可以看这个。 设置系统为中文 先编辑配置文件 /etc/locale.conf sudo nano /etc/locale.gen 取消掉 en_GB.UTF-8， en_US.UTF-8， zh_CN.UTF-8 的注释 执行 sudo locale-gen 编辑 /etc/locale.conf sudo nano /etc/locale.conf 添加下面内容并保存 12LC_TIME=en_GB.UTF-8LC_COLLATE=C 在 KDE 中设置语言为中文，退出登陆后重启即可 安装输入法 输入法这里选择 fcitx5 ，因为对 KDE 友好，而且也足够好用 sudo pacman -S fcitx5-git fcitx5-gtk-git fcitx5-qt5-git fcitx5-chinese-addons-git kcm-fcitx5-git 这里安装的都是 CN 源上的版本，因为更新的比较快，功能齐全。最后一个 kcm-fcitx5-git 是在 KDE 上的输入法配置面板。 编辑 ~/.pam_environment nano ~/.pam_environment 添加下面内容并保存 123GTK_IM_MODULE=fcitx5QT_IM_MODULE=fcitx5XMODIFIERS=@im=fcitx5 安装完成后在 KDE 的系统设置里面，区域设置，输入法，添加 pinyin 到左边然后应用，就能使用拼音了，当然了还有五笔等一些输入方式，可以自己选 配置 Intel 核显 VA-API 以及 Chromium 的硬件加速通过配置硬件加速，可以获得不错的浏览体验以及视频体验。 先安装相应的驱动： pacman -S vulkan-intel intel-media-driver libva-utils 编辑 ~/.pam_environment nano ~/.pam_environment 写入以下内容并保存。 1LIBVA_DRIVER_NAME=iHD 退出登陆后重新登陆，运行 vainfo ，如果没错误的话，应该会有这样的输出： 1234vainfo: VA-API version: 1.6 (libva 2.5.0)vainfo: Driver version: Intel iHD driver - 1.0.0 vainfo: Supportedprofile and entrypoints...... 接下来就开始安装 Chromiun 并启用一些参数使得硬件加速全开。 安装支持硬件加速版本的 Chromiun pacman -S chromium-vaapi 这个为 AUR 包，但是在 Arch Linux CN 源有已经编译打包好的，直接安装 CN 源上的就好了。 新建配置文件 ~/.config/chromium-flags.conf ： nano ~/.config/chromium-flags.conf 写入 --ignore-gpu-blacklist 并保存退出。（如果原来这个文件存在要确定不能有 --use-gl=egl 这个参数） 打开 Chromium 并打开 about://flags 。 搜索并启用 GPU rasterization ， Out of process rasterization ， Zero-copy rasterizer ， Viz Hit-test SurfaceLayer ， Skia API for OOP-D compositing （如果找不到则忽略，可能被更新加入了） 打开 about://gpu 如果看到以下输出，则说明配置完成 1234567891011121314151617Graphics Feature StatusCanvas: Hardware acceleratedFlash: Hardware acceleratedFlash Stage3D: Hardware acceleratedFlash Stage3D Baseline profile: Hardware acceleratedCompositing: Hardware acceleratedMultiple Raster Threads: EnabledOut-of-process Rasterization: Hardware acceleratedHardware Protected Video Decode: Hardware acceleratedRasterization: Hardware acceleratedSkia Renderer: EnabledVideo Decode: Hardware acceleratedViz Display Compositor: EnabledViz Hit-test Surface Layer: EnabledVulkan: DisabledWebGL: Hardware acceleratedWebGL2: Hardware accelerated 切换 IO 调度器（可选） 新建文件 /etc/udev/rules.d/60-ioschedulers.rules sudo nano /etc/udev/rules.d/60-ioschedulers.rules 写入下面内容并保存。 12ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]|mmcblk[0-9]*&quot;, ATTR{queue/rotational}==&quot;0&quot;, ATTR{queue/scheduler}=&quot;mq-deadline&quot;ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;1&quot;, ATTR{queue/scheduler}=&quot;bfq&quot; 开启 SSD Trim sudo systemctl enable fstrim.timer 大概就想到这么多，其他的以后补上。 后记 换了 macOS(Hackintosh) 了，真香！","link":"/2019/12/30/some-tweaks-after-install-arch-linux/"},{"title":"利用 UUP Dump 下载 Windows 镜像","text":"最近被安利回 Windows ，感觉还是不错的。在回来的路上，兔子推荐了 UUP Dump 这个网站，可以很方便地下载 Windows 镜像（Insider 版本），感觉还是不错的，比从微软官方下载或者 itellyou 上的 ed2k 都要方便很多。写一点推荐一下。 打开网站就可以看到很多版本的 Windows 镜像，也可以通过搜索来获取指定版本的镜像。（可能需要手动设置一下才会显示中文） 以搜索 19041.21 这个版本为例，我们可以看到搜索出来了这些结果，分别对应了桌面版、服务器、不同架构的镜像。一般选择 Windows 开头的 Insider 版本即可。 接下来就是对镜像的内容进行一些设置，比如语言、系统版本、集成内容等。语言选中文就可以啦。然后版本的话，没有特殊需要的话直接选单个的 Pro 就好啦，可以缩小镜像的大小。在第三个设置页面里，先选择第三个下载方式，可以增加一些其他版本的安装选项和一些附加内容，比如企业版、教育版、专业工作站版， .Net 3.5 框架等等，我一般会选择安装企业版，因为可以关闭的选项会比其他的版本多。 设置完成后，会下载一个压缩包，里面包含了刚才所选的配置和下载工具，以及下载脚本（bat 和 sh 两种格式），这个脚本会下载需要的文件然后合成一个 ISO 文件，这个文件就是 Windows 的安装镜像了，挂载提取到 FAT32 格式的 U 盘中，通过 U 盘启动就可以开始安装系统了。 注：在 Linux/macOS 环境下可能会缺失一些工具，需要手动安装。","link":"/2020/01/27/use-uup-dump-to-download-windows-install-image/"},{"title":"坚果 Pro 3 以及 Smartisan OS 7.2.2.1 开箱体验","text":"最终还是入手了又一部坚果。 因为受够了 EMMC 5.1 的缓慢，在家又抑制不住剁手之力，于是在苏宁天猫店购入了这台 Pro 3 ，换掉手上的 Pro 2S 。算起来这个已经是手上第三台坚果 Pro 系列手机了。一起来看看没有了罗老师的坚果手机，会是什么样吧。 手机外观废话不多说，先看东西，图不多，就几张。（没什么拍照的好环境，就随手拍了两张，下次好好拍www 竖条方案，化整为零，将各种元素打散，搭配附加元素，统一特征造型，调整间距，得到乱中有序的造型 终于用上了锤科的白色机子。这次白色机子不会太贵，我买的时候苏宁/官网折扣价叠加优惠券大概是 2449/2499 ，而且苏宁有 24 期免息，简直就是不要钱。（敲 正面就没什么好说的了，刘海屏，还有点下巴，千元机水平，不过还好有个屏下指纹，显示效果也还算可以，就勉强接受了。 上手手感侧面类似 iPhone 4S 的三层结构，加上 6.39 英寸的屏幕，对我来说还是挺大的，上半部分的屏幕需要变换手势才能碰到，不过这个在之前用别的手机的时候就习惯了，没啥好说的。但是这次 Pro 3 的大 R 角给了我一定的缓解，在变换手势的时候不会那么难受，而且得益于侧边比较宽的边框，手心的肉不会按到屏幕了，突然开心。（（（ 重量的话，看官网参数是要比坚果 Pro 2S 重上 20 克，但是实际上手感觉也差不多。 这部分大概就是这样了吧，待我多用几天看看有没有新的体验。 系统体验Smartisan OS （以下简称 SOS ）从诞生至今一直饱受争议，如今更新到 7.0 的大版本，来看看现在的它又怎样。 因为博客图片样式受限，本文放的都是拼接压缩后的图片，稍后会有另外一篇文章是截图原图。 如果之前有使用过 SOS 的话，可以发现这次升级可谓是大改动。整体的风格都往活泼的方向调整， 显得更有活力。新的字体 Smartisan T 黑的使用，使得整体的可读性有所提高，字重效果也得到了完善（虽然据说在一些地方字重还是有问题）。 这次 UI 调整里，我最喜欢的就是天气应用的调整和输入法的调整。天气不仅增加了增加了信息量，美观性也提高了很多；输入法这套新皮肤可以说非常适合 SOS 7.0 的整体风格，反正我看了是很有打字的想法。 SOS 是出了名的固执，但是其实在 7.0 版本中，也是有很多听取意见的地方，比如音量控制面板、状态栏的亮度调节，都为大众做了适配。不过我个人是不太喜欢这次改动，这个格状的进度条其实跟系统显得有点格格不入，如果能换回原来那种条形进度条再加以修饰应该会更好看些。 通知管理也跟上了 Android 大版本的步伐，支持根据通知的类型来分类设置，可以定向屏蔽掉一些通知。（但是快捷操作那些你也跟上啊喂！）这次也有游戏模式之类的，而且这次不再是之前的清理内存然后关闭 VPN 之类的了，有了一个侧边栏，通知消息的模式也可以更改，应该算是一个比较游戏的游戏模式了。 剩下的就是 SOS 的一点特色功能了。 新版一步真的蛮好用的，真前台，随意切换www 。以前的拖拽功能在这个控制台的加持下，效率进一步提升。 系统截图，短按快捷键直接保存，长按快捷键可以调出如下编辑界面，除了长截图、套手机壳、涂鸦和分享原有的几个功能以外，新版还加入了二维码识别，方便不少。 第三个就是今年的特色功能，识别系统声音并转换为文字，平时关掉声音看无字幕的视频也没问题了。 以及一些人性化的优化和细节。 锁屏单击空白处可以隐藏时间等其他挡住壁纸的元素，这样就不担心老婆被挡住了！（敲 短信的操作逻辑也更符合一些操作直觉。 系统大概就看到这里吧，到时候看看需不需要写一篇深度的系统体验。 其他感受 整机：上手使用了两天，对这一代手机还是比较满意的，硬件基本达到主流旗舰水平，品控也是相对较好，没有遇到什么很奇怪的问题，系统优化也是做足了，日常使用没有遇到卡顿之类的问题，不过有时候会感觉网速慢，不知是家里的网络问题还是手机的问题，之前使用 Pro 2S 是没问题的，过阵子再检测一下问题吧。 续航：使用锤子手机的时候一直不会在意续航，即使手机只有 50% 的电量我也会直接出门，这次 Pro 3 的续航也算中规中矩吧，虽然不是用着主打低功耗的 CPU ，但是使用起来也不会说续航多差，估计新机都是这样吧，过阵子看看如何。 相机：能拍照，功能多，具体出片等下次。 个人残念拿到新机是挺开心的，但是还是有些不满： 盒子里面配送的充电套装是 18W USB A 口的充电器和对应的数据线，不是 C 口的充电器，有点可惜。 出厂贴膜不是很好，疏油效果一般，容易沾指纹。 屏幕边框有一点点瑕疵，SIM 卡托于卡槽之间的间隙有点大。 除了机子外部的一些不满之外，系统也有些细节令我不开心： 桌面下滑默认是搜索且不能关闭，希望能增加一个开关，甚至能改成下拉状态栏。 计算器依旧不能显示历史计算记录，上方的一大块空白就是空白。 系统流量统计依旧无法自定义统计周期，只能按照自然月开始，就别说支持日租卡等其他类型的流量套餐了。 锁屏抖音的开关有点隐蔽，而且，位置不太对，在设置桌面壁纸的地方也可以设置。 系统自带浏览器的版本还是 Chromium 62 ，历史遗留问题了。 看起来还是蛮多的，希望后面能慢慢改进吧。 简单总结坚果 Pro 3 作为经历各种风波后的回归之作，可以看的出团队的目标已经有所改变，这个改变是为了生存而作出的改变，只有生存下去了，才能做自己想做的。不过希望在改变的同时，能坚持初心，将原本好的东西坚持下来。 坚果 Pro 3 是一部合格的手机，有着合格的硬件、合格的操作系统和合理的价格，但是注定是不会被大众广泛接受的手机。在方方面面还有着各种妥协各种瑕疵，但是这些都是可以被克服或者修正的，期待后面的完善吧。 坚果 Pro 3 ，你好。❤️","link":"/2020/02/28/using-smartisan-nut-pro-3-running-smartisan-os-7-2-2-1/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"Room","slug":"Room","link":"/tags/Room/"},{"name":"SQLite","slug":"SQLite","link":"/tags/SQLite/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Travis CI","slug":"Travis-CI","link":"/tags/Travis-CI/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Netplan","slug":"Netplan","link":"/tags/Netplan/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"BottomNavigationView","slug":"BottomNavigationView","link":"/tags/BottomNavigationView/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"Arch Linux","slug":"Arch-Linux","link":"/tags/Arch-Linux/"},{"name":"Tweaks","slug":"Tweaks","link":"/tags/Tweaks/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"安利","slug":"安利","link":"/tags/%E5%AE%89%E5%88%A9/"},{"name":"Smartisan OS","slug":"Smartisan-OS","link":"/tags/Smartisan-OS/"},{"name":"坚果 Pro 3","slug":"坚果-Pro-3","link":"/tags/%E5%9D%9A%E6%9E%9C-Pro-3/"},{"name":"开箱体验","slug":"开箱体验","link":"/tags/%E5%BC%80%E7%AE%B1%E4%BD%93%E9%AA%8C/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Tech","slug":"Tech","link":"/categories/Tech/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"}]}